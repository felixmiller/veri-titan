include "decls.vad"

#verbatim
include "../code/vale.dfy"
include "../code/example_lemmas.dfy"

include "../spec/def.dfy"
include "../spec/ops.dfy"

include "../gen/decls.dfy"

module examples {

import opened bignum_vale
import opened example_lemmas

import opened bignum_def
import opened ops

import opened bignum_decls

#endverbatim

ghost procedure lemma_xor_clear(ghost x:int)
    ensures xor256(x, x, false, 0) == 0;
    extern;

ghost procedure lemma_sb_nop(ghost x:int)
    ensures uint256_ls(x, 0) == x;
    ensures uint256_rs(x, 0) == x;
    extern;

procedure DoubleExample32(inout dst:reg32, in src:reg32)
    requires
        src + src < 0x1_0000_0000;
    ensures
        dst = old(src) + old(src);
{
    Add32(dst, src, src);
}

procedure DoubleRegExample32()
    requires
        x2 + x2 < 0x1_0000_0000;
    ensures
        x2 = old(x2) + old(x2);
    modifies
        x2;
{
    Add32(x2, x2, x2);
}

procedure half_mul()
// procedure half_mul(in src1:reg256, in src2:reg256)
    reads w28; w29;
    modifies wacc; w1;
{
    // BN.MULQACC.Z w28.0, w29.0, 0
    BN_MULQACC_Z(w28, 0, w29, 0, 0);

    assert(wacc == uint256_qmul(w28, 0, w29, 0)) by {
        lemma_sb_nop(uint256_qmul(w28, 0, w29, 0));
        assert(wacc == uint256_ls(uint256_qmul(w28, 0, w29, 0), 0));
    }

    // BN.MULQACC w28.1, w29.0, 1
    BN_MULQACC(w28, 1, w29, 0, 1);
    // assert(wacc == mulqacc256(true, w28, 0, w29, 0, 0, old(wacc)));

    // BN.MULQACC.SO w1.L, w28.0, w29.1, 1
    BN_MULQACC_SO(w1, true, w28, 1, w29, 0, 1);
    
    // BN.MULQACC w28.2, w29.0, 0
    BN_MULQACC(w28, 2, w29, 0, 0);
    
    // BN.MULQACC w28.1, w29.1, 0
    BN_MULQACC(w28, 1, w29, 1, 0);

    // BN.MULQACC w28.0, w29.2, 0
    BN_MULQACC(w28, 0, w29, 2, 0);

    // BN.MULQACC w28.3, w29.0, 1
    BN_MULQACC(w28, 3, w29, 0, 1);

    // BN.MULQACC w28.2, w29.1, 1
    BN_MULQACC(w28, 2, w29, 1, 1);

    // BN.MULQACC w28.1, w29.2, 1
    BN_MULQACC(w28, 1, w29, 2, 1);

    // BN.MULQACC.SO w1.U, w28.0, w29.3, 1
    BN_MULQACC_SO(w1, false, w28, 0, w29, 3, 1);
}

procedure Increment(inout dst:reg32)
    ensures
        dst == old(dst) + 1;
{
    Addi32(dst, dst, 1);
}

procedure LoopExample(inout dst:reg32)
    requires
        dst == 0;
    ensures
        dst == 3;
    modifies
        flags;
{
    while (dst < 3)
        invariant 0 <= dst <= 3;
        decreases 3 - dst;
    {
        Increment(dst);
    }
}

procedure d0inv()
    modifies
        w0; w29; flags;
{
    lemma_xor_clear(w0);

    Xor256(w0, w0, w0, false, 0);
    Addi256(w0, w0, 1, false);
    Mov256(w29, w0);
    assert(w29 == 1);

    // while (true)
    //     decreases *;
    // {
    //     Mulqacc256(false, w28, 1, w29, 0, 1);
    // }
}

#verbatim
}
#endverbatim
