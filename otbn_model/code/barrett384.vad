include "decls.vad"
include "otbn_mul.vad"

#verbatim
include "../code/vale.dfy"
include "../code/otbn_mul_lemmas.dfy"

include "../spec/def.dfy"
include "../spec/ops.dfy"
include "../spec/types.dfy"

include "../gen/decls.dfy"
include "../gen/otbn_mul.dfy"

module barrett384 {

import opened bignum_vale

import opened bignum_def
import opened ops
import opened types

import opened bignum_decls

import opened otbn_mul_lemmas
import opened otbn_mul

#endverbatim

procedure mul384()
    reads
        w8; w9; w10; w11; w31;
    modifies
        wacc; w18; w17; w16; flags;
{
    half_mul(w16, w8, w10);

    //  bn.mulqacc                w8.0, w11.0,    0
    BN_MULQACC(w8, 0, w11, 0, 0);

    //  bn.mulqacc                w8.1, w10.3,    0
    BN_MULQACC(w8, 1, w10, 3, 0);

    //  bn.mulqacc                w8.2, w10.2,    0
    BN_MULQACC(w8, 2, w10, 2, 0);

    //  bn.mulqacc                w8.3, w10.1,    0
    BN_MULQACC(w8, 3, w10, 1, 0);

    //  bn.mulqacc                w9.0, w10.0,    0
    BN_MULQACC(w9, 0, w10, 0, 0);

    //  bn.mulqacc                w8.0, w11.1,  64
    BN_MULQACC(w8, 0, w11, 1, 1);

    //  bn.mulqacc                w8.1, w11.0,  64
    BN_MULQACC(w8, 1, w11, 0, 1);

    //  bn.mulqacc                w8.2, w10.3,  64
    BN_MULQACC(w8, 2, w10, 3, 1);

    //  bn.mulqacc                w8.3, w10.2,  64
    BN_MULQACC(w8, 3, w10, 2, 1);

    //  bn.mulqacc                w9.0, w10.1,  64
    BN_MULQACC(w9, 0, w10, 1, 1);

    //  bn.mulqacc.so w17.L,  w9.1, w10.0,  64
    BN_MULQACC_SO(w17, true, w9, 1, w10, 0, 1);

    //  bn.mulqacc                w8.1, w11.1,    0
    BN_MULQACC(w8, 1, w11, 1, 0);

    //  bn.mulqacc                w8.2, w11.0,    0
    BN_MULQACC(w8, 2, w11, 0, 0);

    //  bn.mulqacc                w8.3, w10.3,    0
    BN_MULQACC(w8, 3, w10, 3, 0);

    //  bn.mulqacc                w9.0, w10.2,    0
    BN_MULQACC(w9, 0, w10, 2, 0);

    //  bn.mulqacc                w9.1, w10.1,    0
    BN_MULQACC(w9, 1, w10, 1, 0);
        
    //  bn.mulqacc                w8.2, w11.1,  64
    BN_MULQACC(w8, 2, w11, 1, 1);

    //  bn.mulqacc                w8.3, w11.0,  64
    BN_MULQACC(w8, 3, w11, 0, 1);

    //  bn.mulqacc                w9.0, w10.3,  64
    BN_MULQACC(w9, 0, w10, 3, 1);

    //  bn.mulqacc.so w17.U,  w9.1, w10.2,  64
    BN_MULQACC_SO(w17, false, w9, 1, w10, 2, 1);

    //  bn.mulqacc                w8.3, w11.1,    0
    BN_MULQACC(w8, 3, w11, 1, 0);

    //  bn.mulqacc                w9.0, w11.0,    0
    BN_MULQACC(w9, 0, w11, 0, 0);

    //  bn.mulqacc                w9.1, w10.3,    0
    BN_MULQACC(w9, 1, w10, 3, 0);

    //  bn.mulqacc                w9.0, w11.1,  64
    BN_MULQACC(w9, 0, w11, 1, 1);

    //  bn.mulqacc.so w18.L,  w9.1, w11.0,  64
    BN_MULQACC(w9, 0, w11, 1, 1);

    //  bn.mulqacc.so w18.U,  w9.1, w11.1,    0
    BN_MULQACC_SO(w18, false, w9, 1, w11, 1, 0);

    //  bn.add w18, w18, w31
    BN_ADD(w18, w18, w31, false, 0, false);
}
     
procedure barrett384()
    reads
        w12; w13; w14; w15; w31;
    modifies
        w8; w9; w10; w11; w16; w17; w18; w19; 
        w20; w21; w22; w23; w24; w25; w29; w30; 
        flags; wacc;
{
    /* Compute the integer product of the operands x = a * b
        x = [w18, w17, w16] = a * b = [w9, w8] * [w11, w10]
        => max. length x: 768 bit */
    // jal x1, mul384

    // /* Store correction factor to compensate for later neglected MSb of x.
    //     x is 768 bit wide and therefore the 383 bit right shifted version q1
    //     (below) contains 385 bit. Bit 384 of q1 is neglected to allow using a
    //     384x384 multiplier. For the MSb of x being set we temporary store u
    //     (or zero) here to be used in a later constant time correction of a
    //     multiplication with u. Note that this requires the MSb flag being carried
    //     over from the multiplication routine. */
    // bn.sel w24, w14, w31, M
    // bn.sel w25, w15, w31, M

    // /* Save lower 512 bits of x: r1 = [w22, w21] = x % 2^512 = [w16, w17]
    //     => max length r1: 512 bits */
    // bn.mov w21, w16
    // bn.mov w22, w17

    // /* Compute q1 = x >> 383
    //     q1 = [w9, w8] = [w18, w17, w16] >> 383  = [w18, w17] >> 127
    //     => max length q1: 385 bits */
    // bn.rshi w9, w18, w31 >> 127
    // bn.rshi w8, w17, w18 >> 127

    // /* Compute q2 = q1*u
    //     Instead of full q2 (which would be up to 770 bits) we ignore the MSb of u
    //     and the MSb of q1 and correct this later. This allows using a 384x384
    //     multiplier. For special modili where the lower half of the second limb of
    //     u is zero (e.g. p384) this can be further optimized by only considering
    //     limb 0 of u and use a 384x256 multiplication.
    //     => max. length q2': 768 bit
    //     q2' = q1[383:0]*u[383:0] = [w18, w17, w16] = [w9, w8] * [w15, w14] */
    // bn.mov w10, w14
    // bn.mov w11, w15
    // jal x1, mul384

    // /* q3 = q2 >> 385
    //     In this step, the compensation for the neglected MSbs of q1 and u is
    //     carried out underway. To add them in the q2 domain, they would have to be
    //     left shifted by 384 bit first. To directly add them we first shift q2' by
    //     384 bit to the right, perform the additions, and shift the result another
    //     bit to the right. The additions cannot overflow due to leading zeros
    //     after shift.
    //     q2'' = q2' >> 384 = [w20, w19] = [w18, w17, w16] >> 384
    //                                 = [w18, w17] >> 128 */
    // bn.rshi w20, w18, w31 >> 128
    // bn.rshi w19, w17, w18 >> 128
    // /* Add q1. This is unconditional since MSb of u is always 1.
    //     This cannot overflow due to leading zeros.
    //     q2''' = q2'' + q1 = [w20, w19] = [w20, w19] + [w8, w9] */
    // bn.add w19, w19, w8
    // bn.addc w20, w20, w9
    // /* Conditionally add u (without leading 1) in case of MSb of x being set.
    //     This is the "real" q2 but shifted by 384 bits to the right. This cannot
    //     overflow due to leading zeros
    //     q2'''' = x[767]?q2'''+u[383:0]:q2'''
    //         = [w20, w19] + [w25, w24] = q2 >> 384 */
    // bn.add w19, w19, w24
    // bn.addc w20, w20, w25
    // /* finally this gives q3 by shifting the remain bit to the right
    //     q3 = q2 >> 385 = q2'''' >> 1 = [w9, w8] = [w20, w19] >> 1 */
    // bn.rshi w9, w20, w31 >> 1
    // bn.rshi w8, w19, w20 >> 1

    // /* Compute r2 = (q3 * m) % 2^512 = [_, w17, w16] = [w9, w8] * [w13, w12] */
    // bn.mulqacc.z          w8.0, w12.0,   0
    // bn.mulqacc            w8.0, w12.1,  64
    // bn.mulqacc.so w16.L,  w8.1, w12.0,  64
    // bn.mulqacc            w8.0, w12.2,   0
    // bn.mulqacc            w8.1, w12.1,   0
    // bn.mulqacc            w8.2, w12.0,   0
    // bn.mulqacc            w8.0, w12.3,  64
    // bn.mulqacc            w8.1, w12.2,  64
    // bn.mulqacc            w8.2, w12.1,  64
    // bn.mulqacc.so w16.U,  w8.3, w12.0,  64
    // bn.mulqacc            w8.0, w13.0,   0
    // bn.mulqacc            w8.1, w12.3,   0
    // bn.mulqacc            w8.2, w12.2,   0
    // bn.mulqacc            w8.3, w12.1,   0
    // bn.mulqacc            w9.0, w12.0,   0
    // bn.mulqacc            w8.0, w13.1,  64
    // bn.mulqacc            w8.1, w13.0,  64
    // bn.mulqacc            w8.2, w12.3,  64
    // bn.mulqacc            w8.3, w12.2,  64
    // bn.mulqacc            w9.0, w12.1,  64
    // bn.mulqacc.so w17.L,  w9.1, w12.0,  64
    // bn.mulqacc            w8.1, w13.1,   0
    // bn.mulqacc            w8.2, w13.0,   0
    // bn.mulqacc            w8.3, w12.3,   0
    // bn.mulqacc            w9.0, w12.2,   0
    // bn.mulqacc            w9.1, w12.1,   0
    // bn.mulqacc            w8.2, w13.1,  64
    // bn.mulqacc            w8.3, w13.0,  64
    // bn.mulqacc            w9.0, w12.3,  64
    // bn.mulqacc.so w17.U,  w9.1, w12.2,  64

    // /* Compute the estimate for the remainder. This estimate can never be smaller
    //     but at least 2*m greater than the exact value. Therefore it is sufficient
    //     to consider the lower 2 limbs only.
    //     r = [w22, w21] = x-q3*m = r - (q3*m % 2^512) = [w22, w21] - [w17, w16] */
    // bn.sub w21, w21, w16
    // bn.subb w22, w22, w17

    // /* Barrett algorithm requires subtraction of the modulus at most two times if
    //     result is too large. */
    // bn.sub w29, w21, w12
    // bn.subb w30, w22, w13
    // bn.sel w21, w21, w29, C
    // bn.sel w22, w22, w30, C
    // bn.sub w29, w21, w12
    // bn.subb w30, w22, w13
    // bn.sel w29, w21, w29, C
    // bn.sel w30, w22, w30, C

    // /* return result: c =[w29, w30] =  a * b % m. */
}

#verbatim
}
#endverbatim
