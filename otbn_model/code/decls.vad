include{:verbatim} "vale.dfy"
include{:verbatim} "../spec/def.dfy"
include{:verbatim} "../spec/ops.dfy"

#verbatim
module bignum_decls {

import opened ops
import opened bignum_vale
import opened bignum_def
#endverbatim

type state:Type(0) {:primitive} extern;
type uint32:Type(0) := int_range(0, 0xffff_ffff);
type seq(a:Type(0)):Type(0) {:primitive} extern;
type map(a:Type(0), b:Type(0)):Type(0) extern;
type Bignum:Type(0) extern;
type Frame:Type(0) := map(int, uint32);
type Stack:Type(0) := seq(Frame);

function operator(.ok) (s:state):bool extern;
function operator(.ok :=) (s:state, b:bool):state extern;

function BitwiseAnd(x:uint32, y:uint32):uint32 extern;
function BitwiseXor(x:uint32, y:uint32):uint32 extern;
function BitwiseAdd32(x:uint32, y:uint32):uint32 extern;
function xor32(x:uint32, y:uint32):uint32 extern;
function or32(x:uint32, y:uint32):uint32 extern;
function and32(x:uint32, y:uint32):uint32 extern;
function not32(x:uint32):uint32 extern;
function shl32(x:uint32, amount:uint32):uint32 extern; // TODO: requires clause
function shr32(x:uint32, amount:uint32):uint32 extern; // TODO: requires clause
function sext32(x:uint32, size:int):uint32 extern;

function BignumXor(a:Bignum, b:Bignum):Bignum extern;

var ok:bool {:state ok()};

var x0:uint32 {:state reg32(Gpr(0))};
var x1:uint32 {:state reg32(Gpr(1))};
var x2:uint32 {:state reg32(Gpr(2))};
var x3:uint32 {:state reg32(Gpr(3))};
var x4:uint32 {:state reg32(Gpr(4))};
var x5:uint32 {:state reg32(Gpr(5))};
var x6:uint32 {:state reg32(Gpr(6))};
var x7:uint32 {:state reg32(Gpr(7))};
var x8:uint32 {:state reg32(Gpr(8))};
var x9:uint32 {:state reg32(Gpr(9))};
var x10:uint32 {:state reg32(Gpr(10))};
var x11:uint32 {:state reg32(Gpr(11))};
var x12:uint32 {:state reg32(Gpr(12))};
var x13:uint32 {:state reg32(Gpr(13))};
var x14:uint32 {:state reg32(Gpr(14))};
var x15:uint32 {:state reg32(Gpr(15))};
var x16:uint32 {:state reg32(Gpr(16))};
var x17:uint32 {:state reg32(Gpr(17))};
var x18:uint32 {:state reg32(Gpr(18))};
var x19:uint32 {:state reg32(Gpr(19))};
var x20:uint32 {:state reg32(Gpr(20))};
var x21:uint32 {:state reg32(Gpr(21))};
var x22:uint32 {:state reg32(Gpr(22))};
var x23:uint32 {:state reg32(Gpr(23))};
var x24:uint32 {:state reg32(Gpr(24))};
var x25:uint32 {:state reg32(Gpr(25))};
var x26:uint32 {:state reg32(Gpr(26))};
var x27:uint32 {:state reg32(Gpr(27))};
var x28:uint32 {:state reg32(Gpr(28))};
var x29:uint32 {:state reg32(Gpr(29))};
var x30:uint32 {:state reg32(Gpr(30))};
var x31:uint32 {:state reg32(Gpr(31))};

var w0:Bignum {:state Bignum(0)};
var w1:Bignum {:state Bignum(1)};
var w2:Bignum {:state Bignum(2)};
var w3:Bignum {:state Bignum(3)};
var w4:Bignum {:state Bignum(4)};
var w5:Bignum {:state Bignum(5)};
var w6:Bignum {:state Bignum(6)};
var w7:Bignum {:state Bignum(7)};
var w8:Bignum {:state Bignum(8)};
var w9:Bignum {:state Bignum(9)};
var w10:Bignum {:state Bignum(10)};
var w11:Bignum {:state Bignum(11)};
var w12:Bignum {:state Bignum(12)};
var w13:Bignum {:state Bignum(13)};
var w14:Bignum {:state Bignum(14)};
var w15:Bignum {:state Bignum(15)};
var w16:Bignum {:state Bignum(16)};
var w17:Bignum {:state Bignum(17)};
var w18:Bignum {:state Bignum(18)};
var w19:Bignum {:state Bignum(19)};
var w20:Bignum {:state Bignum(20)};
var w21:Bignum {:state Bignum(21)};
var w22:Bignum {:state Bignum(22)};
var w23:Bignum {:state Bignum(23)};
var w24:Bignum {:state Bignum(24)};
var w25:Bignum {:state Bignum(25)};
var w26:Bignum {:state Bignum(26)};
var w27:Bignum {:state Bignum(27)};
var w28:Bignum {:state Bignum(28)};
var w29:Bignum {:state Bignum(29)};
var w30:Bignum {:state Bignum(30)};
var w31:Bignum {:state Bignum(31)};

var wmod:Bignum {:state Bignum(WMod)};
var wrnd:Bignum {:state Bignum(WRnd)};

//var flags:map(int, bool) {:state flags()};
var stack:Stack {:state stack()};

operand_type reg32:uint32 :=
| inout x0 | inout x1 | inout x2 | inout x3
| inout x4 | inout x5 | inout x6 | inout x7
| inout x9 | inout x9 | inout x10 | inout x11
| inout x12 | inout x13 | inout x14 | inout x15
| inout x16 | inout x17 | inout x18 | inout x19
| inout x20 | inout x21 | inout x22 | inout x23
| inout x24 | inout x25 | inout x26 | inout x27
| inout x28 | inout x29 | inout x30 | inout x31
| inout xrnd
;

operand_type reg256:Bignum :=
| inout w0 | inout w1 | inout w2 | inout w3
| inout w4 | inout w5 | inout w6 | inout w7
| inout w9 | inout w9 | inout w10 | inout w11
| inout w12 | inout w13 | inout w14 | inout w15
| inout w16 | inout w17 | inout w18 | inout w19
| inout w20 | inout w21 | inout w22 | inout w23
| inout w24 | inout w25 | inout w26 | inout w27
| inout w28 | inout w29 | inout w30 | inout w31
| inout wmod | inout wrnd
;

operand_type imm32:uint32 := uint32;

procedure Add32(inout dst:reg32, in src1:reg32, in src2:reg32)
    {:instruction Ins32(ADD32(dst, src1, src2))}
    ensures
        dst == (old(src1) + old(src2)) & 0xFFFF_FFFF;
{
assume false;
}

procedure Addi32(inout dst:reg32, in src1:reg32, in src2:imm32)
    {:instruction Ins32(ADDI32(dst, src1, src2))}
    requires
        src2 < 0x1000;
    ensures
        dst = old(src1) + sext32(old(src2), 12);
{
assume false;
}

procedure Sub32(inout dst:reg32, in src1:reg32, in src2:reg32)
    {:instruction Ins32(SUB32(dst, src1, src2))}
    ensures
        dst == (old(src1) - old(src2)) & 0xFFFF_FFFF;
{
assume false;
}

procedure And32(inout dst:reg32, in src1:reg32, in src2:reg32)
    {:instruction Ins32(AND32(dst, src1, src2))}
    ensures
        dst == and32(old(src1), old(src2));
{
assume false;
}

procedure Andi32(inout dst:reg32, in src1:reg32, in src2:imm32)
    {:instruction Ins32(ANDI32(dst, src1, src2))}
    requires
        src2 < 0x1000;
    ensures
        dst == and32(old(src1), sext32(old(src2), 12));
{
assume false;
}

procedure Or32(inout dst:reg32, in src1:reg32, in src2:reg32)
    {:instruction Ins32(OR32(dst, src1, src2))}
    ensures
        dst == or32(old(src1), old(src2));
{
assume false;
}

procedure Ori32(inout dst:reg32, in src1:reg32, in src2:imm32)
    {:instruction Ins32(ORI32(dst, src1, src2))}
    requires
        src2 < 0x1000;
    ensures
        dst == or32(old(src1), sext32(old(src2), 12));
{
assume false;
}

procedure Xor32(inout dst:reg32, in src1:reg32, in src2:reg32)
    {:instruction Ins32(XOR32(dst, src1, src2))}
    ensures
        dst == xor32(old(src1), old(src2));
{
assume false;
}

procedure Xori32(inout dst:reg32, in src1:reg32, in src2:imm32)
    {:instruction Ins32(XORI32(dst, src1, src2))}
    requires
        src2 < 0x1000;
    ensures
        dst == xor32(old(src1), sext32(old(src2), 12));
{
assume false;
}

procedure Lui32(inout dst:reg32, src:imm32)
    {:instruction Ins32(LUI32(dst, src))}
    requires
        src < 0x100000; // 20-bit immediate
    ensures
        dst = shl32(old(src), 12)
{
assume false;
}

// TODO: Handle case where dst is x0
procedure Csrrw32(inout dst:reg32, csr:reg32, src:reg32)
    {:instruction Ins32(CSRRW32(dst, csr, src))}
    requires
        ValidCsr(csr);
    ensures
        dst = old(csr);
	csr = old(src);
{
assume false;
}


#verbatim
} // end module bignum_decls
#endverbatim
